# 电影推荐系统项目手册

## 目录
1. [项目设计架构](#1-项目设计架构)
2. [系统各模块设计与实现](#2-系统各模块设计与实现)
   - [2.1 数据模型设计](#21-数据模型设计)
   - [2.2 用户认证模块](#22-用户认证模块)
   - [2.3 电影浏览模块](#23-电影浏览模块)
   - [2.4 用户行为模块](#24-用户行为模块)
   - [2.5 推荐系统模块](#25-推荐系统模块)
   - [2.6 用户中心模块](#26-用户中心模块)
   - [2.7 后台管理模块](#27-后台管理模块)

---

## 1. 项目设计架构

### 1.1 技术栈

本项目采用Django框架构建，主要技术栈包括：

- **后端框架**：Django 5.2.8
- **数据库**：MySQL
- **前端技术**：HTML、CSS、JavaScript、Bootstrap
- **AI服务**：阿里云通义千问API
- **数据采集**：Python爬虫（豆瓣电影）

### 1.2 系统架构设计

系统采用经典的MVC（Model-View-Controller）架构模式，具体对应Django的MTV（Model-Template-View）模式：

```
┌───────────────────────────────┐
│    前端展示层 (Templates)      │ 
│  - HTML模板                   │
│  - 静态资源 (CSS/JS)          │
└──────────────────────────────┘
                    ↓
┌────────────────────────────────┐
│     业务逻辑层 (Views)          │
│  - 视图函数处理请求             │
│  - 业务逻辑实现                 │
│  - API接口                     │
└───────────────────────────────┘
                    ↓
┌───────────────────────────────┐
│     数据模型层 (Models)        │
│  - Movie（电影）               │
│  - UserInfo（用户）            │
│  - UserAction（用户行为）      │
└───────────────────────────────┘
                    ↓
┌───────────────────────────────┐
│    数据存储层 (MySQL)          │
└───────────────────────────────┘
```

### 1.3 项目目录结构

```
DjangoProject/
├── DjangoProject/          # 项目主配置目录
│   ├── settings.py         # 项目配置文件
│   ├── urls.py             # 主URL路由配置
│   ├── wsgi.py             # WSGI配置
│   └── asgi.py             # ASGI配置
├── myapp/                  # 主应用目录
│   ├── models.py           # 数据模型定义
│   ├── views.py            # 视图函数
│   ├── urls.py             # 应用URL路由
│   ├── forms.py            # 表单定义
│   ├── admin.py            # 后台管理配置
│   └── migrations/         # 数据库迁移文件
├── templates/              # 模板文件目录
│   ├── base.html           # 基础模板
│   ├── home/               # 首页模板
│   ├── movies/             # 电影相关模板
│   ├── auth/               # 认证相关模板
│   ├── account/            # 用户中心模板
│   └── recommend/          # 推荐页面模板
├── static/                 # 静态文件目录
│   └── css/                # CSS样式文件
├── spiders/                # 爬虫脚本目录
│   └── get.py              # 豆瓣电影数据采集脚本
└── manage.py               # Django管理脚本
```

### 1.4 核心设计理念

1. **模块化设计**：将功能按模块划分，便于维护和扩展
2. **前后端分离**：提供RESTful API接口，支持前后端分离开发
3. **个性化推荐**：基于用户行为的协同过滤推荐 + AI智能推荐
4. **用户体验优化**：响应式设计，支持AJAX异步操作

---

## 2. 系统各模块设计与实现

### 2.1 数据模型设计

#### 2.1.1 Movie模型（电影信息）

**设计说明**：存储电影的基本信息，包括标题、评分、发布日期、海报、演员、地区、类型和简介。

**代码实现**：

```python
# myapp/models.py

class Movie(models.Model):
    title = models.CharField(max_length=255, verbose_name='电影标题')
    score = models.FloatField(null=True, blank=True, verbose_name='评分')
    date = models.DateField(null=True, blank=True, verbose_name='发布日期')
    poster = models.URLField(max_length=255, null=True, blank=True, verbose_name='海报链接')
    actors = models.CharField(max_length=255, null=True, blank=True, verbose_name='演员表')
    region = models.CharField(max_length=255, null=True, blank=True, verbose_name='地区')
    type = models.CharField(max_length=255, null=True, blank=True, verbose_name='类型')
    summary = models.TextField(null=True, blank=True, verbose_name='简介')

    class Meta:
        verbose_name = '电影'
        verbose_name_plural = '电影集'

    def __str__(self):
        return self.title
```

**设计要点**：
- 使用`CharField`存储文本信息，`TextField`存储长文本
- 所有字段设置为可空，适应数据不完整的情况
- 使用`URLField`存储海报链接，便于前端直接使用

#### 2.1.2 UserInfo模型（用户信息）

**设计说明**：继承Django的`AbstractUser`，扩展用户信息字段，包括用户ID、昵称、性别、年龄等。

**代码实现**：

```python
# myapp/models.py

class UserManager(BaseUserManager):
    def _create_user(self, username, email, password, **kwargs):
        if not username:
            raise ValueError('请输入用户名')
        if not email:
            raise ValueError('请输入邮箱')
        if not password:
            raise ValueError('请输入密码')
        user = self.model(username=username, email=email, **kwargs)
        user.set_password(password)
        user.save()
        return user

    def create_user(self, username, email, password, **kwargs):
        kwargs['is_superuser'] = False
        return self._create_user(username, email, password, **kwargs)

    def create_superuser(self, username, email, password, **kwargs):
        kwargs['is_superuser'] = True
        kwargs['is_staff'] = True
        return self._create_user(username, email, password, **kwargs)

class UserInfo(AbstractUser, PermissionsMixin):
    user_ID = models.CharField(max_length=32, null=False, verbose_name="用户ID")
    username = models.CharField(max_length=255, null=False, verbose_name="用户名", unique=True)
    password = models.CharField(max_length=255, null=False, verbose_name="用户密码")
    nickname = models.CharField(max_length=255, null=False, verbose_name="用户昵称")
    sex_choice = {
        (1, "男"),
        (2, "女")
    }
    sex = models.IntegerField(choices=sex_choice, null=False, verbose_name="性别", default=1)
    age = models.IntegerField(verbose_name="年龄", null=True)
    email = models.EmailField(null=False, verbose_name="邮箱", unique=False)
    registration = models.DateTimeField(auto_now_add=True, verbose_name="创建时间", null=False)
    last_login = models.DateTimeField(auto_now_add=True, verbose_name="上次登录时间", null=False)
    
    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = ['email']
    EMAIL_FIELD = 'email'
    objects = UserManager()

    def __str__(self):
        return self.username
```

**设计要点**：
- 自定义`UserManager`实现用户创建逻辑
- 使用`choices`字段限制性别选项
- 自动记录注册时间和最后登录时间
- 在`settings.py`中配置`AUTH_USER_MODEL = 'myapp.UserInfo'`

#### 2.1.3 UserAction模型（用户行为）

**设计说明**：记录用户对电影的操作，包括评分、收藏和评论，支持一个用户对一部电影的多种行为。

**代码实现**：

```python
# myapp/models.py

class UserAction(models.Model):
    """用户行为：评分、收藏与评论"""
    user = models.ForeignKey("UserInfo", on_delete=models.CASCADE, related_name="actions")
    movie = models.ForeignKey("Movie", on_delete=models.CASCADE, related_name="actions")
    rating = models.FloatField(null=True, blank=True, verbose_name="评分")
    comment = models.TextField(null=True, blank=True, verbose_name="评论")
    is_favorite = models.BooleanField(default=False, verbose_name="收藏")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("user", "movie")

    def __str__(self):
        return f"{self.user.username}-{self.movie.title}"
```

**设计要点**：
- 使用`ForeignKey`建立用户和电影的多对多关系
- `unique_together`确保一个用户对一部电影只有一条记录
- 使用`auto_now_add`和`auto_now`自动管理时间戳
- 支持评分、收藏、评论三种行为的组合

---

### 2.2 用户认证模块

#### 2.2.1 登录功能

**设计说明**：实现用户登录验证，使用Django的`authenticate`和`login`函数。

**代码实现**：

```python
# myapp/views.py

def login_user(request):
    if request.method == "POST":
        form = LoginForm(request.POST)
        if form.is_valid():
            user = form.cleaned_data["user"]
            login(request, user)
            messages.success(request, "登录成功")
            return redirect("/")
    else:
        form = LoginForm()
    return render(request, "auth/login.html", {"form": form})
```

**表单定义**：

```python
# myapp/forms.py

class LoginForm(forms.Form):
    username = forms.CharField(label="用户名", max_length=150)
    password = forms.CharField(label="密码", widget=forms.PasswordInput)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields["username"].widget.attrs.update({"class": "form-control"})
        self.fields["password"].widget.attrs.update({"class": "form-control"})

    def clean(self):
        cleaned_data = super().clean()
        username = cleaned_data.get("username")
        password = cleaned_data.get("password")
        if username and password:
            user = authenticate(username=username, password=password)
            if not user:
                raise forms.ValidationError("用户名或密码错误")
            cleaned_data["user"] = user
        return cleaned_data
```

**设计要点**：
- 使用Django表单系统进行数据验证
- 在`clean`方法中进行用户认证
- 认证成功后使用`login`函数建立会话
- 使用`messages`框架提供用户反馈

#### 2.2.2 注册功能

**设计说明**：实现新用户注册，包括信息验证和密码加密。

**代码实现**：

```python
# myapp/views.py

def register_user(request):
    if request.method == "POST":
        form = RegistrationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            messages.success(request, "注册成功，已自动登录")
            return redirect("/")
    else:
        form = RegistrationForm()
    return render(request, "auth/register.html", {"form": form})
```

**表单定义**：

```python
# myapp/forms.py

class RegistrationForm(forms.ModelForm):
    password1 = forms.CharField(label="密码", widget=forms.PasswordInput)
    password2 = forms.CharField(label="确认密码", widget=forms.PasswordInput)

    class Meta:
        model = UserInfo
        fields = ["username", "email", "nickname", "sex", "age"]

    def clean_password2(self):
        password1 = self.cleaned_data.get("password1")
        password2 = self.cleaned_data.get("password2")
        if password1 and password2 and password1 != password2:
            raise forms.ValidationError("两次密码输入不一致")
        return password2

    def clean_username(self):
        username = self.cleaned_data["username"]
        if UserInfo.objects.filter(username=username).exists():
            raise forms.ValidationError("用户名已存在")
        return username

    def clean_email(self):
        email = self.cleaned_data["email"]
        if UserInfo.objects.filter(email=email).exists():
            raise forms.ValidationError("邮箱已被注册")
        return email

    def save(self, commit=True):
        user = super().save(commit=False)
        user.user_ID = uuid.uuid4().hex
        user.set_password(self.cleaned_data["password1"])
        if commit:
            user.save()
        return user
```

**设计要点**：
- 使用`ModelForm`简化表单定义
- 实现密码确认验证
- 检查用户名和邮箱唯一性
- 使用`uuid`生成唯一用户ID
- 使用`set_password`进行密码加密

#### 2.2.3 登出功能

**代码实现**：

```python
# myapp/views.py

def logout_user(request):
    logout(request)
    messages.info(request, "已退出登录")
    return redirect("/")
```

---

### 2.3 电影浏览模块

#### 2.3.1 首页展示

**设计说明**：首页展示轮播图、高分电影、最新电影和推荐电影。

**代码实现**：

```python
# myapp/views.py

def home(request):
    # 轮播图：选择评分最高的5部电影
    carousel_movies = Movie.objects.filter(score__isnull=False).order_by("-score")[:5]
    top_rated = Movie.objects.order_by("-score")[:8]
    latest = Movie.objects.order_by("-date")[:8]
    recommend = _personalized_recommendations(request.user, limit=6) if request.user.is_authenticated else _hot_recommendations(limit=6)
    return render(
        request,
        "home/index.html",
        {
            "carousel_movies": carousel_movies,
            "top_rated": top_rated,
            "latest": latest,
            "recommend": recommend,
        },
    )
```

**设计要点**：
- 根据用户登录状态显示个性化推荐或热门推荐
- 使用数据库查询优化，限制返回数量
- 按评分和日期排序

#### 2.3.2 电影列表

**设计说明**：支持关键词搜索、地区筛选、类型筛选和排序功能。

**代码实现**：

```python
# myapp/views.py

def movie_list(request):
    keyword = request.GET.get("q")
    region = request.GET.get("region")
    mtype = request.GET.get("type")
    sort = request.GET.get("sort", "-date")

    qs = Movie.objects.all()
    if keyword:
        qs = qs.filter(Q(title__icontains=keyword) | Q(actors__icontains=keyword) | Q(summary__icontains=keyword))
    if region:
        qs = qs.filter(region__icontains=region)
    if mtype:
        qs = qs.filter(type__icontains=mtype)
    if sort not in ["-date", "-score", "date", "score"]:
        sort = "-date"
    qs = qs.order_by(sort)

    paginator = Paginator(qs, 12)
    page_number = request.GET.get("page")
    page_obj = paginator.get_page(page_number)

    return render(
        request,
        "movies/list.html",
        {
            "page_obj": page_obj,
            "regions": Movie.objects.exclude(region__isnull=True).exclude(region="").values_list("region", flat=True).distinct()[:30],
            "types": Movie.objects.exclude(type__isnull=True).exclude(type="").values_list("type", flat=True).distinct()[:30],
            "querystring": _querystring_without_page(request),
            "sort": sort,
            "keyword": keyword or "",
            "region": region or "",
            "mtype": mtype or "",
        },
    )
```

**设计要点**：
- 使用`Q`对象实现复杂查询（标题、演员、简介搜索）
- 支持多条件组合筛选
- 使用`Paginator`实现分页功能
- 保留查询参数用于分页链接

#### 2.3.3 电影详情

**设计说明**：展示电影详细信息，包括相关电影推荐和用户评论。

**代码实现**：

```python
# myapp/views.py

def movie_detail(request, pk):
    movie = get_object_or_404(Movie, pk=pk)
    related = Movie.objects.filter(type=movie.type).exclude(pk=pk).order_by("-score")[:6]
    action = None
    if request.user.is_authenticated:
        action = UserAction.objects.filter(user=request.user, movie=movie).first()
    # 获取所有评论（有评分或评论的）
    from django.db.models import Q
    comments = UserAction.objects.filter(
        movie=movie
    ).filter(
        Q(rating__isnull=False) | Q(comment__isnull=False, comment__gt="")
    ).select_related("user").order_by("-updated_at")
    return render(
        request,
        "movies/detail.html",
        {
            "movie": movie,
            "related": related,
            "action": action,
            "comments": comments,
        },
    )
```

**设计要点**：
- 使用`get_object_or_404`处理不存在的电影
- 根据电影类型推荐相关电影
- 显示当前用户的评分和收藏状态
- 使用`select_related`优化数据库查询

#### 2.3.4 排行榜

**代码实现**：

```python
# myapp/views.py

def top_list(request):
    region = request.GET.get("region")
    mtype = request.GET.get("type")
    qs = Movie.objects.all()
    if region:
        qs = qs.filter(region__icontains=region)
    if mtype:
        qs = qs.filter(type__icontains=mtype)
    qs = qs.order_by("-score")

    paginator = Paginator(qs, 12)
    page_number = request.GET.get("page")
    page_obj = paginator.get_page(page_number)

    return render(
        request,
        "movies/top.html",
        {
            "page_obj": page_obj,
            "regions": Movie.objects.exclude(region__isnull=True).exclude(region="").values_list("region", flat=True).distinct()[:30],
            "types": Movie.objects.exclude(type__isnull=True).exclude(type="").values_list("type", flat=True).distinct()[:30],
            "querystring": _querystring_without_page(request),
        },
    )
```

---

### 2.4 用户行为模块

#### 2.4.1 收藏功能

**设计说明**：支持用户收藏/取消收藏电影，提供同步和异步两种方式。

**同步方式（页面跳转）**：

```python
# myapp/views.py

@login_required
def toggle_favorite(request, pk):
    movie = get_object_or_404(Movie, pk=pk)
    action, _ = UserAction.objects.get_or_create(user=request.user, movie=movie)
    action.is_favorite = not action.is_favorite
    action.save()
    messages.success(request, "已收藏" if action.is_favorite else "已取消收藏")
    return redirect("movie_detail", pk=pk)
```

**异步方式（AJAX）**：

```python
# myapp/views.py

@login_required
def toggle_favorite_api(request, pk):
    if request.method != "POST":
        return JsonResponse({"error": "method not allowed"}, status=405)
    movie = get_object_or_404(Movie, pk=pk)
    action, _ = UserAction.objects.get_or_create(user=request.user, movie=movie)
    action.is_favorite = not action.is_favorite
    action.save()
    return JsonResponse({"is_favorite": action.is_favorite})
```

**设计要点**：
- 使用`@login_required`装饰器确保用户已登录
- 使用`get_or_create`避免重复创建记录
- 提供JSON响应支持AJAX调用

#### 2.4.2 评分功能

**设计说明**：支持用户对电影进行评分（0-10分）。

**代码实现**：

```python
# myapp/views.py

@login_required
def rate_movie(request, pk):
    movie = get_object_or_404(Movie, pk=pk)
    try:
        rating = float(request.POST.get("rating"))
    except (TypeError, ValueError):
        messages.error(request, "评分格式不正确")
        return redirect("movie_detail", pk=pk)
    action, _ = UserAction.objects.get_or_create(user=request.user, movie=movie)
    action.rating = max(0, min(10, rating))
    action.save()
    messages.success(request, f"已评分 {action.rating}")
    return redirect("movie_detail", pk=pk)

@login_required
def rate_movie_api(request, pk):
    if request.method != "POST":
        return JsonResponse({"error": "method not allowed"}, status=405)
    movie = get_object_or_404(Movie, pk=pk)
    try:
        rating = float(request.POST.get("rating"))
    except (TypeError, ValueError):
        return JsonResponse({"error": "invalid rating"}, status=400)
    rating = max(0, min(10, rating))
    action, _ = UserAction.objects.get_or_create(user=request.user, movie=movie)
    action.rating = rating
    action.save()
    return JsonResponse({"rating": action.rating})
```

**设计要点**：
- 验证评分格式和范围（0-10）
- 使用`max`和`min`确保评分在有效范围内

#### 2.4.3 评论功能

**设计说明**：支持用户对电影进行评论，可同时提交评分和评论。

**代码实现**：

```python
# myapp/views.py

@login_required
def submit_comment(request, pk):
    """提交评论（可同时评分和评论）"""
    if request.method != "POST":
        return JsonResponse({"error": "method not allowed"}, status=405)
    movie = get_object_or_404(Movie, pk=pk)
    action, _ = UserAction.objects.get_or_create(user=request.user, movie=movie)
    
    # 处理评分
    rating = request.POST.get("rating")
    if rating:
        try:
            rating = float(rating)
            rating = max(0, min(10, rating))
            action.rating = rating
        except (TypeError, ValueError):
            pass
    
    # 处理评论
    comment = request.POST.get("comment", "").strip()
    if comment:
        action.comment = comment
    
    action.save()
    
    return JsonResponse({
        "success": True,
        "rating": action.rating,
        "comment": action.comment,
        "user": request.user.nickname or request.user.username,
        "updated_at": action.updated_at.strftime("%Y-%m-%d %H:%M:%S")
    })
```

**设计要点**：
- 支持单独评论或同时评分和评论
- 返回JSON格式数据，包含用户信息和时间戳

---

### 2.5 推荐系统模块

#### 2.5.1 个性化推荐（基于协同过滤）

**设计说明**：分析用户的历史行为（收藏、评分），提取用户偏好的类型和演员，推荐相似电影。

**代码实现**：

```python
# myapp/views.py

def _split_tokens(value):
    """分割标签字符串（支持多种分隔符）"""
    if not value:
        return []
    tokens = value.replace("，", ",").replace("、", ",").replace("|", ",").replace("/", ",").split(",")
    return [t.strip() for t in tokens if t.strip()]

def _personalized_recommendations(user, limit=24):
    """基于用户行为的个性化推荐"""
    actions = (
        UserAction.objects.filter(user=user)
        .select_related("movie")
        .order_by("-updated_at")[:200]
    )
    if not actions:
        return None

    type_counter, actor_counter = Counter(), Counter()
    seen_movie_ids = set()
    for action in actions:
        m = action.movie
        seen_movie_ids.add(m.id)
        type_counter.update(_split_tokens(m.type))
        actor_counter.update(_split_tokens(m.actors))

    top_types = [t for t, _ in type_counter.most_common(5)]
    top_actors = [a for a, _ in actor_counter.most_common(5)]

    filters = Q()
    for t in top_types:
        filters |= Q(type__icontains=t)
    for a in top_actors:
        filters |= Q(actors__icontains=a)

    qs = Movie.objects.exclude(id__in=seen_movie_ids)
    if filters:
        qs = qs.filter(filters)
    qs = qs.order_by("-score", "-date")[:limit]
    return qs if qs else None
```

**设计要点**：
- 使用`Counter`统计用户偏好的类型和演员
- 排除用户已看过的电影
- 使用`Q`对象构建复杂查询条件
- 按评分和日期排序推荐结果

#### 2.5.2 热门推荐

**代码实现**：

```python
# myapp/views.py

def _hot_recommendations(limit=24):
    """热门推荐（按评分排序）"""
    return Movie.objects.order_by("-score", "-date")[:limit]
```

#### 2.5.3 AI智能推荐

**设计说明**：集成阿里云通义千问API，基于用户偏好数据生成个性化推荐。

**核心函数**：

```python
# myapp/views.py

def _format_movie_info(movie, user_rating=None):
    """格式化电影信息用于AI分析"""
    return {
        "title": movie.title,
        "type": movie.type or "未知",
        "region": movie.region or "未知",
        "actors": movie.actors or "未知",
        "score": movie.score,
        "rating": user_rating,
    }

def _get_user_preference_data(user, limit=10):
    """获取用户偏好数据用于AI分析"""
    favorites = (
        UserAction.objects.filter(user=user, is_favorite=True)
        .select_related("movie")
        .order_by("-updated_at")[:limit]
    )
    
    top_rated = (
        UserAction.objects.filter(user=user, rating__isnull=False)
        .select_related("movie")
        .order_by("-rating", "-updated_at")[:limit]
    )
    
    return {
        "favorites": [_format_movie_info(action.movie, action.rating) for action in favorites],
        "top_rated": [_format_movie_info(action.movie, action.rating) for action in top_rated],
    }

def _build_recommendation_prompt(user_data):
    """构建推荐请求的prompt"""
    favorites_text = ""
    if user_data['favorites']:
        favorites_text = "用户收藏的电影：\n" + "\n".join([
            f"- {m['title']}（类型：{m['type']}，地区：{m['region']}，豆瓣评分：{m['score']}）"
            for m in user_data['favorites']
        ])
    
    top_rated_text = ""
    if user_data['top_rated']:
        top_rated_text = "用户评分最高的电影：\n" + "\n".join([
            f"- {m['title']}（类型：{m['type']}，地区：{m['region']}，用户评分：{m['rating']}分，豆瓣评分：{m['score']}）"
            for m in user_data['top_rated']
        ])
    
    prompt = f"""你是一位专业的电影推荐专家。基于用户的观影偏好，请推荐5-8部电影。

{favorites_text}

{top_rated_text}

请分析用户的观影偏好（类型、地区、风格等），然后：
1. 推荐5-8部符合用户口味的电影
2. 为每部推荐电影提供简短的推荐理由（20-30字）
3. 推荐理由要说明为什么这部电影适合这个用户

请以JSON格式返回，格式如下：
{{
    "analysis": "对用户观影偏好的简短分析（50字以内）",
    "recommendations": [
        {{
            "title": "电影标题（准确的电影名称）",
            "type": "电影类型（如：剧情、喜剧、动作等）",
            "region": "电影地区（如：美国、中国、日本等）",
            "score": 8.5,
            "reason": "推荐理由（20-30字）"
        }}
    ]
}}

注意：
1. 只返回JSON，不要其他文字
2. 电影标题要准确
3. type和region字段尽量填写，如果不知道可以填"未知"
4. score字段填写豆瓣评分（0-10之间的数字），如果不知道可以填null
5. 推荐理由要具体说明为什么适合这个用户"""
    
    return prompt

def _call_qwen_api(prompt):
    """调用通义千问API"""
    api_key = getattr(settings, 'QWEN_API_KEY', '')
    api_url = getattr(settings, 'QWEN_API_URL', 'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation')
    
    if not api_key:
        return None, None, "API Key未配置"
    
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    data = {
        "model": "qwen-turbo",
        "input": {
            "messages": [
                {
                    "role": "system",
                    "content": "你是一位专业的电影推荐专家，擅长分析用户观影偏好并推荐合适的电影。"
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        },
        "parameters": {
            "temperature": 0.7,
            "max_tokens": 2000
        }
    }
    
    try:
        response = requests.post(api_url, headers=headers, json=data, timeout=30)
        response.raise_for_status()
        result = response.json()
        
        # 解析通义千问的响应格式
        content = None
        if 'output' in result and 'text' in result['output']:
            content = result['output']['text']
        elif 'output' in result and 'choices' in result['output']:
            if len(result['output']['choices']) > 0:
                if 'message' in result['output']['choices'][0]:
                    content = result['output']['choices'][0]['message']['content']
                elif 'text' in result['output']['choices'][0]:
                    content = result['output']['choices'][0]['text']
        
        if content:
            return content, str(result), None
        else:
            return None, str(result), f"API响应格式错误，无法提取内容。响应: {result}"
    except requests.exceptions.RequestException as e:
        return None, None, f"API请求失败: {str(e)}"
    except Exception as e:
        return None, None, f"API调用异常: {str(e)}"

def _extract_json_from_response(text):
    """从AI响应中提取JSON"""
    # 尝试直接解析
    try:
        return json.loads(text)
    except:
        pass
    
    # 尝试提取JSON块
    json_match = re.search(r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}', text, re.DOTALL)
    if json_match:
        try:
            return json.loads(json_match.group())
        except:
            pass
    
    # 尝试提取```json代码块
    json_block_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
    if json_block_match:
        try:
            return json.loads(json_block_match.group(1))
        except:
            pass
    
    return None

@login_required
def ai_recommend_api(request):
    """AI推荐API"""
    if request.method != "POST":
        return JsonResponse({"error": "method not allowed"}, status=405)
    
    user = request.user
    
    # 获取用户偏好数据
    user_data = _get_user_preference_data(user)
    
    # 检查是否有足够的数据
    if not user_data['favorites'] and not user_data['top_rated']:
        return JsonResponse({
            "success": False,
            "error": "数据不足",
            "message": "请先收藏或评分一些电影，以便AI分析你的观影偏好"
        }, status=400)
    
    # 构建prompt
    prompt = _build_recommendation_prompt(user_data)
    
    # 调用AI API
    ai_response, raw_response, error_msg = _call_qwen_api(prompt)
    
    if not ai_response:
        return JsonResponse({
            "success": False,
            "error": "API调用失败",
            "message": error_msg or "请稍后重试",
            "raw_response": raw_response if raw_response else None
        }, status=500)
    
    # 解析AI返回的JSON
    try:
        ai_data = _extract_json_from_response(ai_response)
        
        if not ai_data:
            return JsonResponse({
                "success": False,
                "error": "JSON解析失败",
                "message": "AI返回格式不正确，但已显示原始回答",
                "raw_ai_response": ai_response,
                "raw_api_response": raw_response
            }, status=500)
        
        # 处理推荐结果
        recommendations = []
        for rec in ai_data.get('recommendations', []):
            title = rec.get('title', '').strip()
            if not title:
                continue
            
            # 尝试在数据库中查找（用于获取海报等额外信息）
            movie = Movie.objects.filter(title=title).first()
            if not movie:
                movie = Movie.objects.filter(title__icontains=title).first()
            
            recommendation = {
                "id": movie.id if movie else None,
                "title": title,
                "poster": movie.poster if movie and movie.poster else "",
                "score": rec.get('score') or (movie.score if movie else None),
                "type": rec.get('type') or (movie.type if movie else "") or "未知",
                "region": rec.get('region') or (movie.region if movie else "") or "未知",
                "reason": rec.get('reason', '推荐给你')
            }
            recommendations.append(recommendation)
        
        response_data = {
            "success": True,
            "analysis": ai_data.get('analysis', '基于你的观影偏好，为你推荐以下电影'),
            "recommendations": recommendations,
            "raw_ai_response": ai_response,
        }
        
        if not recommendations:
            response_data.update({
                "success": False,
                "error": "无推荐数据",
                "message": "AI未返回推荐电影，但已显示AI的原始回答",
            })
            return JsonResponse(response_data, status=404)
        
        return JsonResponse(response_data)
    except json.JSONDecodeError as e:
        return JsonResponse({
            "success": False,
            "error": "JSON解析失败",
            "message": f"解析错误: {str(e)}，但已显示原始回答",
            "raw_ai_response": ai_response,
            "raw_api_response": raw_response
        }, status=500)
    except Exception as e:
        return JsonResponse({
            "success": False,
            "error": "处理失败",
            "message": str(e),
            "raw_ai_response": ai_response if 'ai_response' in locals() else None,
            "raw_api_response": raw_response if 'raw_response' in locals() else None
        }, status=500)
```

**配置说明**：

```python
# DjangoProject/settings.py

# ==================== AI推荐配置 ====================
# 通义千问API配置
# 获取API Key: https://dashscope.console.aliyun.com/
QWEN_API_KEY = 'sk-e818738ab2584b678022307dcb3a692e'
QWEN_API_URL = 'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation'
```

**设计要点**：
- 构建结构化的prompt，包含用户偏好数据
- 使用正则表达式提取JSON，处理多种响应格式
- 在数据库中查找推荐电影，补充海报等信息
- 提供详细的错误处理和调试信息

---

### 2.6 用户中心模块

#### 2.6.1 个人资料

**设计说明**：展示用户的收藏和评分记录。

**代码实现**：

```python
# myapp/views.py

def profile(request):
    if request.user.is_anonymous:
        messages.info(request, "请先登录")
        return redirect("login")
    favorites = (
        UserAction.objects.filter(user=request.user, is_favorite=True)
        .select_related("movie")
        .order_by("-updated_at")
    )
    rated = (
        UserAction.objects.filter(user=request.user, rating__isnull=False)
        .select_related("movie")
        .order_by("-updated_at")
    )
    return render(
        request,
        "account/profile.html",
        {
            "user_obj": request.user,
            "favorites": favorites,
            "rated": rated,
        },
    )
```

#### 2.6.2 资料编辑

**代码实现**：

```python
# myapp/views.py

@login_required
def profile_edit(request):
    form = ProfileForm(request.POST or None, instance=request.user)
    if request.method == "POST":
        if form.is_valid():
            form.save()
            messages.success(request, "资料已更新")
            return redirect("profile")
    return render(request, "account/edit.html", {"form": form})
```

**表单定义**：

```python
# myapp/forms.py

class ProfileForm(forms.ModelForm):
    class Meta:
        model = UserInfo
        fields = ["nickname", "email", "sex", "age"]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        widgets_map = {
            "nickname": "form-control",
            "email": "form-control",
            "sex": "form-select",
            "age": "form-control",
        }
        for name, css in widgets_map.items():
            if name in self.fields:
                self.fields[name].widget.attrs.update({"class": css})
```

#### 2.6.3 密码修改

**代码实现**：

```python
# myapp/views.py

@login_required
def profile_password(request):
    form = PasswordUpdateForm(user=request.user, data=request.POST or None)
    if request.method == "POST":
        if form.is_valid():
            user = form.save()
            update_session_auth_hash(request, user)
            messages.success(request, "密码已更新")
            return redirect("profile")
    return render(request, "account/password.html", {"form": form})
```

#### 2.6.4 用户统计

**设计说明**：展示用户的观影统计数据，包括收藏统计、评分统计、类型分布、地区分布和趋势分析。

**代码实现**：

```python
# myapp/views.py

@login_required
def user_stats(request):
    """用户统计数据页面"""
    user = request.user
    
    # 收藏统计
    favorites = UserAction.objects.filter(user=user, is_favorite=True).select_related("movie")
    favorite_count = favorites.count()
    
    # 评分统计
    rated = UserAction.objects.filter(user=user, rating__isnull=False).select_related("movie")
    rated_count = rated.count()
    avg_rating = rated.aggregate(avg=Avg("rating"))["avg"] or 0
    
    # 评分分布（0-2, 2-4, 4-6, 6-8, 8-10）
    rating_dist = {"range_0_2": 0, "range_2_4": 0, "range_4_6": 0, "range_6_8": 0, "range_8_10": 0}
    for action in rated:
        r = action.rating
        if r < 2:
            rating_dist["range_0_2"] += 1
        elif r < 4:
            rating_dist["range_2_4"] += 1
        elif r < 6:
            rating_dist["range_4_6"] += 1
        elif r < 8:
            rating_dist["range_6_8"] += 1
        else:
            rating_dist["range_8_10"] += 1
    
    # 收藏影片的类型统计
    favorite_types = Counter()
    for action in favorites:
        if action.movie.type:
            types = _split_tokens(action.movie.type)
            favorite_types.update(types)
    top_types = dict(favorite_types.most_common(10))
    
    # 收藏影片的地区统计
    favorite_regions = Counter()
    for action in favorites:
        if action.movie.region:
            regions = _split_tokens(action.movie.region)
            favorite_regions.update(regions)
    top_regions = dict(favorite_regions.most_common(10))
    
    # 评分影片的类型统计
    rated_types = Counter()
    for action in rated:
        if action.movie.type:
            types = _split_tokens(action.movie.type)
            rated_types.update(types)
    top_rated_types = dict(rated_types.most_common(10))
    
    # 评分影片的地区统计
    rated_regions = Counter()
    for action in rated:
        if action.movie.region:
            regions = _split_tokens(action.movie.region)
            rated_regions.update(regions)
    top_rated_regions = dict(rated_regions.most_common(10))
    
    # 月度收藏趋势
    from django.utils import timezone
    from datetime import timedelta
    monthly_favorites = {}
    for action in favorites:
        month_key = action.created_at.strftime("%Y-%m")
        monthly_favorites[month_key] = monthly_favorites.get(month_key, 0) + 1
    
    # 月度评分趋势
    monthly_ratings = {}
    for action in rated:
        month_key = action.created_at.strftime("%Y-%m")
        if month_key not in monthly_ratings:
            monthly_ratings[month_key] = []
        monthly_ratings[month_key].append(action.rating)
    monthly_avg_ratings = {k: sum(v) / len(v) for k, v in monthly_ratings.items()}
    
    return render(
        request,
        "account/stats.html",
        {
            "user_obj": user,
            "favorite_count": favorite_count,
            "rated_count": rated_count,
            "avg_rating": round(avg_rating, 2),
            "rating_dist": rating_dist,
            "top_types": json.dumps(top_types, ensure_ascii=False),
            "top_regions": json.dumps(top_regions, ensure_ascii=False),
            "top_rated_types": json.dumps(top_rated_types, ensure_ascii=False),
            "top_rated_regions": json.dumps(top_rated_regions, ensure_ascii=False),
            "monthly_favorites": json.dumps(monthly_favorites, ensure_ascii=False),
            "monthly_avg_ratings": json.dumps({k: round(v, 2) for k, v in monthly_avg_ratings.items()}, ensure_ascii=False),
        },
    )
```

**设计要点**：
- 使用`Counter`统计类型和地区分布
- 计算评分分布和平均值
- 生成月度趋势数据
- 将数据转换为JSON格式供前端图表使用

---

### 2.7 后台管理模块

#### 2.7.1 电影管理

**设计说明**：在Django Admin中管理电影信息，支持列表展示、筛选、搜索和编辑。

**代码实现**：

```python
# myapp/admin.py

@admin.register(Movie)
class MovieAdmin(admin.ModelAdmin):
    """电影管理"""
    list_display = ['id', 'title', 'score', 'date', 'region', 'type', 'poster_preview']
    list_filter = ['region', 'type', 'date']
    search_fields = ['title', 'actors', 'summary']
    list_editable = ['score']
    list_per_page = 20
    ordering = ['-id']
    
    fieldsets = (
        ('基本信息', {
            'fields': ('title', 'score', 'date', 'poster')
        }),
        ('详细信息', {
            'fields': ('actors', 'region', 'type', 'summary')
        }),
    )
    
    def poster_preview(self, obj):
        """海报预览"""
        if obj.poster:
            return format_html('<img src="{}" style="max-width: 60px; max-height: 90px; object-fit: cover;" />', obj.poster)
        return '-'
    poster_preview.short_description = '海报'
```

**设计要点**：
- 自定义`list_display`显示关键字段
- 使用`list_filter`提供筛选功能
- 使用`search_fields`支持全文搜索
- 自定义`poster_preview`方法显示海报缩略图

#### 2.7.2 用户管理

**代码实现**：

```python
# myapp/admin.py

@admin.register(UserInfo)
class UserInfoAdmin(BaseUserAdmin):
    """用户管理"""
    list_display = ['id', 'username', 'nickname', 'email', 'sex', 'age', 'is_active', 'is_staff', 'is_superuser', 'registration', 'last_login']
    list_filter = ['is_active', 'is_staff', 'is_superuser', 'sex', 'registration']
    search_fields = ['username', 'nickname', 'email', 'user_ID']
    list_editable = ['is_active']
    list_per_page = 20
    ordering = ['-registration']
    
    fieldsets = (
        ('基本信息', {
            'fields': ('username', 'nickname', 'email', 'password')
        }),
        ('个人信息', {
            'fields': ('sex', 'age', 'user_ID')
        }),
        ('权限', {
            'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions')
        }),
        ('时间信息', {
            'fields': ('registration', 'last_login', 'date_joined')
        }),
    )
    
    add_fieldsets = (
        ('创建用户', {
            'classes': ('wide',),
            'fields': ('username', 'nickname', 'email', 'password1', 'password2', 'sex', 'age'),
        }),
    )
    
    readonly_fields = ['registration', 'last_login', 'date_joined', 'user_ID']
```

#### 2.7.3 用户行为管理

**代码实现**：

```python
# myapp/admin.py

@admin.register(UserAction)
class UserActionAdmin(admin.ModelAdmin):
    """用户行为管理（评分、收藏、评论）"""
    list_display = ['id', 'user', 'movie', 'rating', 'is_favorite', 'comment_preview', 'created_at', 'updated_at']
    list_filter = ['is_favorite', 'rating', 'created_at']
    search_fields = ['user__username', 'user__nickname', 'movie__title', 'comment']
    list_per_page = 20
    ordering = ['-updated_at']
    
    fieldsets = (
        ('关联信息', {
            'fields': ('user', 'movie')
        }),
        ('行为信息', {
            'fields': ('rating', 'is_favorite', 'comment')
        }),
        ('时间信息', {
            'fields': ('created_at', 'updated_at')
        }),
    )
    
    readonly_fields = ['created_at', 'updated_at']
    
    def comment_preview(self, obj):
        """评论预览"""
        if obj.comment:
            preview = obj.comment[:50] + '...' if len(obj.comment) > 50 else obj.comment
            return format_html('<span title="{}">{}</span>', obj.comment, preview)
        return '-'
    comment_preview.short_description = '评论'
```

---

## 3. URL路由配置

### 3.1 主URL配置

```python
# DjangoProject/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('myapp.urls')),
]
```

### 3.2 应用URL配置

```python
# myapp/urls.py

from django.urls import path
from . import views

urlpatterns = [
    # 首页
    path('', views.home, name='home'),
    
    # 认证相关
    path('login/', views.login_user, name='login'),
    path('register/', views.register_user, name='register'),
    path('logout/', views.logout_user, name='logout'),
    
    # 电影相关
    path('top/', views.top_list, name='top'),
    path('movies/', views.movie_list, name='movie_list'),
    path('movies/<int:pk>/', views.movie_detail, name='movie_detail'),
    path('movies/<int:pk>/favorite/', views.toggle_favorite, name='toggle_favorite'),
    path('movies/<int:pk>/rate/', views.rate_movie, name='rate_movie'),
    
    # API接口
    path('movies/<int:pk>/favorite/ajax/', views.toggle_favorite_api, name='toggle_favorite_api'),
    path('movies/<int:pk>/rate/ajax/', views.rate_movie_api, name='rate_movie_api'),
    path('movies/<int:pk>/comment/', views.submit_comment, name='submit_comment'),
    path('api/recommend/', views.recommend_api, name='recommend_api'),
    path('api/ai-recommend/', views.ai_recommend_api, name='ai_recommend_api'),
    
    # 推荐
    path('recommend/', views.recommend_view, name='recommend'),
    
    # 用户中心
    path('profile/', views.profile, name='profile'),
    path('profile/edit/', views.profile_edit, name='profile_edit'),
    path('profile/password/', views.profile_password, name='profile_password'),
    path('profile/stats/', views.user_stats, name='user_stats'),
]
```

---

## 4. 数据库配置

### 4.1 MySQL配置

```python
# DjangoProject/settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'django_1',
        'USER': 'root',
        'PASSWORD': 'zxu7696638',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}
```

### 4.2 自定义用户模型配置

```python
# DjangoProject/settings.py

AUTH_USER_MODEL = 'myapp.UserInfo'
```

---

## 5. 总结

本项目是一个功能完整的电影推荐系统，主要特点包括：

1. **完整的用户系统**：注册、登录、个人资料管理
2. **丰富的电影浏览功能**：列表、详情、搜索、筛选、排序
3. **用户行为记录**：收藏、评分、评论
4. **智能推荐系统**：基于协同过滤的个性化推荐 + AI智能推荐
5. **数据统计分析**：用户观影偏好分析、趋势统计
6. **后台管理**：完善的Django Admin配置

系统采用模块化设计，代码结构清晰，易于维护和扩展。通过集成AI推荐功能，提升了推荐的准确性和用户体验。

